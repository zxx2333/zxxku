# NodeJS

不是一门新的语言，是js语法格式，js本身并不能执行，需要借助宿主环境。浏览器就是js的宿主环境，NodeJs提

供了js执行的环境。

NodeJs搭建web服务器



## 特点

单线程：

​	整个程序只有一个线程执行 （同一时间只能做一件事情）

非阻塞I/O

I/O： Input/Output

从磁盘向内存输入内容，叫做Input

从内存向磁盘输出内容，叫做Output

非阻塞I/O:

​	当js线程执行的时候，如果遇到非阻塞I/O任务，此时只是开启任务，立即执行下一条任务

阻塞I/O:

​	当js线程执行的时候，如果遇到阻塞I/O任务，此时开启任务并等待任务完之后，才会去执行下一个任务



## 事件驱动与使用场景

事件驱动

​	当js线程执行的时候，由于是非阻塞的，线程不会等待任务执行完毕，后面的任务怎么执行，此时会一个事件，

由该事件将后续的任务重新放回js执行队列中(nodejs循环队列)



使用场景

​	nodejs搭建的服务器，适合高并发、异步多，但不适合复杂的计算，计算时同步的，会造成线程阻塞。



 例：

​	去火车站买票，只有一个售卖窗口（单线程），大家为了能够正常购票，排队购票(执行队列)，有一位美女，购

票但是忘记带身份证（I/O阻塞），喊她二大姑给他送（需要时间），管理人员（事件驱动）让她去第二位排队或

者去最后排队(循环队列)。



##  运行nodejs文件

1、去到对应的server.js文件所在目录  切换目录使用 cd

2、window如何切换盘符:  d:

node 文件名（js文件）



## 模块化

CMD： seajs

暴露的变量： seajs和define

暴露接口： 

​	module.exports  exports  return

引用模块：

​	require

AMD: requirejs

暴露的变量: requirejs(require) define

暴露接口：

​	module.exports  exports  return 

​	推荐使用 return

nodejs中

引用模块：

​	require

暴露接口：	

​	module.exports

​	exports

​	不支持return



## 模块的分类

自定义模块和系统核心模块（内置模块）， 一个js文件默认就为一个模块

内置模块：我们要学习的模块：
			path、http、https、fs、url、querystring



## 引入第三方模块

执行代码：（错误示范）

```js
var res = require('demo');
console.log(res);
```





这里在引入自定义的模块的时候，相对路径的 ./ 不能省略
正确的引用方式:

```js
var res = require('./demo');
console.log(res);
```





## 第三方模块文件 node_modules文件夹

如果想让第三方的模块像内置模块一样引入，在引用的js文件的当前文件夹或当前文件夹的父级文件夹下创建node_modules文件夹，将要引入的模块文件放入其中。(类比于作用域，最顶层为所在盘符)



## HTTP模块

该模块用于搭建一个服务器

引入http模块

> demo:

```js
    // 引入http模块
    var http = require('http');	
    // 创建服务器对象
    var server = http.createServer(function() {
        console.log('前端发送了请求');
        // console.log(arguments.length);
    })
    // 设置监听端口号
    server.listen(3000);
```



### 处理函数

http.createServer方法用于创建一个服务器对象
使用方式:http.createServer(handle)， 返回值为HTTP服务器对象
handle: 处理函数

函数中有两个参数:
- req: request 前端本次请求的对象
  - url：表示本次请求的路径, 包含的是path部分和query部分
  - method: 本次请求的方式（是大写的）
  - headers： 请求头信息
- res: response 响应对象，用于返回的内容
  - write： 返回内容，但是不会断开连接
  - end: 返回内容，返回之后会断开连接，接收的数据类型只能是字符串和buffer数据
  - setHeader: 用于设置响应头
  - writeHeader: 跟setHeader类似

- writeHeader和setHeader的区别：
      writeHeader可以设置http返回状态码，多个http响应头。
      但是setHeader只针对单一属性的设置。
      var server = http.createServer(function(req, res) {
      	// req 请求对象    
          // res 响应对象
      })
  - req.method: 请求方式
  - req.url：请求路径
  - res.end(): 响应的内容
  - res.setHeader(): 设置相应头信息



### 监听方法

server.listen(port，ip， callBack)

​		port: 监听端口号

​		ip: 指明ip

​		callBack: 回调函数

执行代码：

```js
// 引用http模块
var http = require('http');
// http是一个对象
// console.log(http);
// 创建http服务
var server = http.createServer(function(req, res) {
    // console.log(req, res);
    // req 请求对象
    // console.log(req);
    // res 相应信息
    // 请求方式
    console.log(req.method);
    // 请求URL地址

	console.log(req.url);
	// console.log(111);
    // 设置响应头信息
    res.setHeader('content-type', 'text/html;charset=utf-8');
    // 返回一条信息： 设置返回的内容
    // res.end('hello world');
    res.end("<b>我爱你中国</b>");
}).listen(3000, function() {
    console.log("后台服务器开始运行了");
});
// 设置监听的端口
// server.listen(3000);
```







## FS模块

file system 文件系统 操作文件及文件夹

引入fs模块

```js
var fs = require('fs');
```



### 创建文件

fs.appendfile(path, data, callBack)
- path: 生成文件的路径，如果文件存在则在原有的内容之后追加内容
- data：要写入的数据
- callBack：执行完毕之后的回调函数
- 回调函数的实参为操作的结果
    - 成功：null
    - 失败：错误对象

执行代码：

```js
// 引入fs模块
var fs = require('fs');
// console.log(fs);
// 创建文件
fs.appendFile('./xxoo/iloveyou', 'i love you forever', function(res) {
    // console.log(arguments);
    /* 
        res返回值的情况：
            成功：null
            失败：对象
    */
    console.log(res);
});
```



### 删除文件

fs.unlink（path, callBack）

- path：文件路径
- callBack： 回调函数



执行代码：

```JS
 // 引入fs模块
    var fs = require('fs');
    // 删除文件                                             
    fs.unlink('./iloveyou', function(res) {
        // 结果同之前的一样   
        console.log(res);
        // console.log(arguments);
    });

```



### 修改文件（文件名、剪切文件、修改文件夹、剪切文件夹）

fs.rename（oldpath，newpath，callBack）

- oldpath:原来的路径
- newpath:新的路径
- callBack：回调函数



执行代码：

```JS
// 引入fs模块
var fs = require('fs');
// 删除文件
fs.rename('oldname', 'newname', function(res) {
    // 结果同之前的一样
    console.log(res);
    // console.log(arguments);
});

```



### 读取文件

fs.readFile(path, callBack)
- path：文件的路径
- callBack：回调函数
  - 成功时：传入两个参数，第一个参数为null，第二个参数为读取到的内容
  - 失败时：只有一个参数，为错误信息的对象

执行代码:

```JS
// 引用fs模块
var fs = require('fs');
// 调用读取文件
fs.readFile('./newname', function(res, arr) {
	// res和之前的结果相同
	// arr成功时为读取到的内容， 失败时不存在
	console.log(res);
	console.log(arr);
	// console.log(arguments);
})

```



### 创建文件夹

fs.mkdir(path, callBack)
- path: 文件夹路径
- callBack：回调函数
  - 成功：null
  - 失败：错误信息对象

执行代码：

```JS
// 引用fs模块
var fs = require('fs');
// 创建目录
fs.mkdir('./xxoo', function(res) {
    // console.log(arguments);
    console.log(res);
});

```



### 读取文件夹

fs.readdir(path, callBack)

- path:读取文件夹的路径
- callBack：回调函数
  - 成功: 第一个实参为null，第二个实参为数组，数组元素为文件夹内的文件和文件夹



### 删除文件夹

fs.rmdir(path, callBack)

执行代码：

```JS
// 引用fs模块
var fs = require('fs');
// 删除目录
fs.rmdir('./003', function(res) {
    console.log(arguments);
    // console.log(res);
});
    
```



### 判断文件夹的状态

fs.stat(path, callBack)

- path: 文件（夹）路径
- callBack: 回调函数
  - 失败： 错误对象
  - 成功：第一个参数为null, 第二个参数为文件对象，可以通过调用对象的方法实现具体其他操作

用来判断文件类型



删除非空目录

try {

​	监测的代码

} cath(e) {

​	e为错误对象

}

不会影响后续代码的执行



## 服务器

服务器的分类
    按照请求的资源类型进行的分类，分为两类
- 静态服务器：  静态网页	请求的资源为html、css、js、图片等
- 动态服务器： 动态网站 登陆、注册等

搭建静态服务器
目标： 浏览器请求那个文件，将对应文件的内容返给浏览器

思路：
- 获得请求文件的路径
- 根据路径找到对应的文件，有则返回没有则给出提示
- 设置对应的头信息
    - 头信息：文件的后缀----> MIME类型
- 当访问的文件夹的时候，让其默认访问该文件夹下的index.html



## 路径问题

根：
- html的根：server.js所在的目录
- node的根： server.js所在的盘符

客户端：
    绝对路径：
    	详细： http://www.baidu.com/1.jpg
    	省略域名： /1.jpg
    相对路径： 
    	html: html文件
    	js:引入他的html文件
    	css:css文件

服务器：
    绝对路径： 
    	/ ：window下，server.js所在盘符
    相对路径： 当前文件



## url模块

引用内置的url模块

```JS
var url = require('url');
```



### parse

将获得的url字符串解析成url对象

parse(str, bool)
- str: 访问的地址
- bool： 是否将查询字符串转为对象的格式，默认值为false

执行代码：

```JS
// 引入url模块
var url = require('url');
// 访问地址
var str = '/web/index.html?name=1';
// parse: 可以将url字符串解析成对象
var url_obj = url.parse(str, true);
console.log(url_obj);

```

### format

 将url_obj对象转为url字符串，是parse的反向操作

执行代码：

```JS
// format: 将url_obj对象转为字符串
    var newstr = url.format(url_obj);
    console.log(newstr);

```



## MIME类型和path模块

MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。

path模块
parse(path)： 将路径解析为对象

join（oldpath, newpath）： 将路径进行拼接
oldpath: 原来的路径
newpath: 目标路径

将原来的路径作为参考，和目标路径进行拼接，形成一个新的路径



## 接口

网站中有一些需求直接在服务器端处理完毕，返回的只是一个结果，而不是请求静态资源。比如注册，登陆等

并不需要返回静态资源，返回一个结果。

执行代码：

```JS
// 判断用户是否在执行登陆操作
    if (url_str == '/dologin') {
        // 设置响应头
        res.setHeader('content-type', 'text/plain;charset=utf-8');
        // 响应信息
        res.end(Math.random() > 0.5 ? '登陆成功': '登陆失败');
    }

```



## querystring模块

模块中的parse方法：

parse(querystr, bigSplit, smallSplit)
        querystr: query字符串，查询字符串
        bigSplit: 分隔键值对的字符串，默认值为&
        smallSplit: 分隔键值对中的键和值的字符串，默认为=



## nodejs处理get

get请求数据是在query字符串中，获得方式

- 通过req对象中的url属性获得请求的路径
- 通过url模块中的parse方法将url字符串解析为对象，注意第二个参数必须为true，保证query字符串解析为对象
- 可以通过query对象获得传输过来的信息



## nodejs处理post

post请求和get请求的区别：

​    **大小**：post传输的数据没有大小限制，get是有大小限制的

​    **方式**：post通过请求体传输数据，get通过url传输数据

nodejs如何获得post传输的数据,通过两个事件来获得传输的数据分别为data和end事件

​    data:当post请求触发的时候，就会触发该事件，该事件会自动传入一个实参，实参为传输的数据 

​    end:当所有数据接收完成会触发该事件

上面的两个事件需要通过请求对象req进行绑定，data事件是可以触发多次的，而end事件只触发一次。

**post获得数据**

- 绑定data事件和end事件
- 在end事件中获得query字符串，该字符串为提交的数据
- 调用querystring模块的parse方法将字符串解析为对象
    POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。
    比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。



## AJAX

在早期浏览器只是为了渲染页面，但是随着发展，js出现单独的解析器，js的功能变得越来越丰富。现在学习的所有的请求有一个共同点都会进行页面的刷新，但是互联网现在更多了为了提升用户的体验，使用了很多的无刷新操作，京东当滚动条下拉至底端的时候，会自动增加新的内容，这些操作都是AJAX实现。

AJAX全称： Asynchronous JavaScript And XML   异步的js和xml

目标： 实现无刷新的数据请求
js实现请求，xml作为数据的传输的格式，现在不使用xml
取而代之的是JSON



### AJAX的使用

在高级浏览器和IE8支持XMLHttpRequest构造函数，低版本支持ActiveXObject（‘Microsoft.XMLHTTP’）
产生一个xhr对象，用于发送请求和接收数据

重要的属性和方法：
onreadystatechange: 该方法用于监听xhr对象的状态码，当状态码发生改变的时候会触发该事件
readyState: xhr对象的状态码 默认值为0
- 0： 表示未初始化
- 1：表示初始化，调用了open方法
- 2：已经接受到了响应头信息，服务器对请求已经处理
- 3：接收到了一部分相应数据
- 4：响应数据全部接收完毕
status: HTTP请求的状态码
responseText: 响应的内容
open方法: 用于建立tcp链接，发送http请求 
send方法：用来发送请求的内容



### 浏览器的兼容处理

1、产生xhr对象,能力检测，兼容浏览器

```JS
if (window.XMLHttpRequest) {
    // 高级浏览器
    var xhr = new XMLHttpRequest();
} else if (window.ActiveXObject('Microsoft.XMLHTTP')) {
    // 低版本IE浏览器
    var xhr = new ActiveXObject('Microsoft.XMLHTTP');
} else {
    throw new Error('请升级浏览器');
}
```



监测事件：

```JS
    // 2、监听事件
    xhr.onreadystatechange = function() {
        // 获得xhr对象的状态
        console.log(xhr.readyState);
    }
```



### 发送请求

发送请求：
xhr.open(method, url, bool)
method: 请求方式  get或者post
url: 你要请求的地址
bool: 是否进行异步请求 默认值为false 表示同步， true代表使用异步请求
    // 3、建立tcp链接，发送请求
    xhr.open('get', '/register', true); 

发送数据：
    // 4、发送数据
    xhr.send();

get请求
get请求服务器端设置:pathname == '/register' && method == 'get'

ajax的post请求：
服务器端代码



### jquery中的ajax

get请求
$.get(url, data, callBack, dataType);
    **url:**待载入页面的URL地址
    **data**:待发送 Key/value 参数。<b style="color:red;">可以使用对象还可以是query字符串</b>
    **callBack**:载入成功时回调函数。回调函数有一个参数为请求回来的数据。
    **dataType**:将返回内容进行解析的格式，xml, html, script, json, text, _default。

post请求
$.post(url, data, callBack, dataType);
    **url:**待载入页面的URL地址
    **data**:待发送 Key/value 参数。<b style="color:red;">可以使用对象还可以是query字符串</b>
    **callBack**:载入成功时回调函数。回调函数有一个参数为请求回来的数据。
    **dataType**:将返回内容进行解析的格式，xml, html, script, json, text, _default。



### ajax通用方式

$.ajax(options);
options是一个配置的对象

url: 请求的地址
type: 请求方式
data：请求的数据
dataType： 返回数据类型，如果返回json字符串，你写json自动转为json对象
success: 成功时执行的回调函数
error： 失败时执行的回调函数
complete: 完成时执行的函数
processData： 布尔值默认为true，表示jquery对数据进行序列化操作
contentType: 布尔值默认值为true，表示让jquery进行设置，jquery默认将content-type设置为application/x-www-form-urlencoded 



## 表单的序列化

ajax的好处，可以实现无刷新请求，不好的地方每一次传输数据都需要手动填写
表单获取的快捷方式： document.forms 获得是一个类数组对象
获得指定的表单： document.forms[index]
jquery中表单的系列化： 表单.serialize();

执行代码：

```JS
	// 使用jquery中的表单序列化
    console.log($(document.forms[0]).serialize());
```



## 转码与解码

编码：encodeURIComponent

解码：decodeURIComponent



执行代码：

```js
xhr.open('get', '/register?username=我爱#你中国&pwd=123', true);
```



在ajax请求的时候传输的数据都应该使用encodeURIComponent进行编码

实现表单的序列化

获得表单：document.forms[index]

获得表单的子元素： form.elements



## 历史事件对象

在h5中提供了history对象，可以用来管理历史记录
前进: forward
后退：back
前进后退： go

添加历史记录： pushState(data, title, url)
    data:传输的数据
    title：设置网页的标题（一般不使用）
    url: 添加的地址

替换历史记录： replaceState(data, title, url)
    data:传输的数据
    title：设置网页的标题（一般不使用）
    url: 替换的地址

检测事件：
    window.onpopstate事件



## FormData构造函数

序列化
FormData是ajax发展到2.0版本新增的构造函数，用于快速将表单中的数据进行序列化

使用方式：
    fd = new FormData(form) 
    form：你要序列化的表单
    
    传参： 直接将表单中的数据序列化，不传入任何的参数，也会得到一个对象fd， 可以通过fd中的方法向其中添加数据。

表单被序列化之后的数据不能直接查看，需要使用forEach



## forEach 

跟数组的forEach及其类似

```js
fd.forEach(function(value, key, fd){
    value为值，key为键，fd为fd对象
})
```



## append  

该方法用于向序列化对象中添加数据
使用方式：

```js
fd.append(key, value)
	key: 键名
	value: 值
```


## delete

通过指定的键名删除指定的键值对

使用方式：

​    fd.delete(key) : key为要删除键值对的键



## get

通过指定的键名获得对应键值对的值（多个值只获得第一个）

使用方式：

​    fd.get(key)

通过指定的键名获得对应键值对的值（获得对应键的所有值）

使用方式：

​    fd.getAll(key)



## has

用于检测序列化的数据对象中是否含有指定键

使用方式：

​    fd.has(key) 

返回值为bool类型，存在为true不存在为false



## set

可以用于修改键值对

使用方式：

​    fd.set(key, value);

存在则修改，没有则添加



## 图片预览

实现上传图片的时候，可以预览图片

FileReader（H5）

​	是一个构造函数，产生一个对象，用于读取上传文件的数据，得到的是一个base64资源

使用方式:

```js
var fr = new FileReader();
```



**文件上传框的属性**：

​    multiple： 可以设置多个文件上传

​    accept ：MIME类型，筛选的过程

**知识点**：

- 获得文件的上传信息 ： file对象.files[index]

- 读取数据： fr.readAsDataURL(上传信息对象) 读取的过程为一个异步的过程

- 读取完成： fr.onload事件

- 获取到的结果为base64 ，直接将img的src指向获得的base64资源即可

 

 window.URL.createObjectURL(file)



## 轮询

轮询就是前端通过ajax请求后端，周期性的请求。

原因就是http协议是一个无状态的协议，用户请求之后，服务器给出响应，这个链接就会断开。

聊天室，需要有内容主动刷新的过程，使用周期执行函数，每隔一段时间向服务器发送一次请求，看是否有新的数

据产生，如果有则请求回来。



## 域与跨域

域

**域**： 域名

文件请求的过程中，域名最终是要解析为ip地址(DNS)



跨域

​	**说明**：

​		发送请求到服务器A，服务器A给出了响应的页面，当页面渲染完毕，通过该页面向服务器B发送请求，这个请求称之为跨域请求



**跨域请求的条件**：

​	协议、域名、端口号不同	

只要满足上诉三个条件中的一个，都可以判定为跨域请求



**同源策略**

​	浏览器有一个同源策略，是不允许跨域请求(ajax)

​	但是，静态资源的请求不受同源策略的影响

​	在html页面引入其他网站的css、js、以及图片等等



## JSONP

JSONP: json + padding

jsonp是实现跨域请求的一种方法，json是一种数据格式

**跨域请求的实现**：

​	利用静态资源的请求不受同源策略的影响，比如img, srcipt标签都是可以的。使用的是script标签，原因script

引用的资源在引入回来之后会被当做代码来执行。做法，将script标签的scr属性指向请求的地址。



## 实现jsonp跨域的步骤

1、使用script标签的scr属性发送请求

2、在服务器端设置指定类型的字符串， 返回的字符串需要拼接为函数调用的形式，真正传输的数据作为函数调用

的实参

3、在发送请求的script标签之前声明对应的函数，并设置对应的形参，用于接收服务器返回的数据



**jquery的跨域**

设置请求地址：http://localhost:3000/getMsg

请求头中的地址：http://localhost:3000/getMsg?callback=jQuery112302632264233457333_1581129662432&_=1581129662433





## https服务器

http是一个无状态的协议，在请求的过程中，只要请求正确不会验证请求的发起者，存在一些安全的风险，如果出

现了数据拦截，个人信息存在安全隐患。https协议等价于 http + ssl，在https请求发送的时候就会进行验证，更

加安全。

想搭建https服务器需要证书

http://localhost:3000/index.html
https://localhost:3000/index.html

通过git的openssl生成证书文件





## Cookie

​    cookie是http协议中请求头的一部分，主要用来验证用户的信息，cookie是由服务器进行设置的，存储在客户

端，cookie是有大小的限制，最大不能超过4kb。



**cookie实现登陆的原理**

​    http是一个无状态的协议，理论上不能够保持登陆的状态。当用户输入账号和密码之后，服务器就收到该信息，

并进行验证，如果用户通过验证，服务器会在响应头中通过set-cookie字段让客户端设置cookie，cookie当中就可

以存放登陆的相关信息，浏览器接收到响应之后，会根据set-cookie字段的要求，在客户端存储 相应的内容。

cookie有一个特点，每当你访问对应的域名的时候，都会自动的将网站的cookie携带过去，服务器就可以根据

cookie字段中的设置，来判断该用户是谁，是否进行登录了等相关信息。 



## session

session实现的功能和cookie是一样的，是cookie的加强版本，session在默认的情况下，依赖于cookie来实现，

cookie将信息存储在客户端，session将信息存储在服务器端。cookie是有大小限制的，session的大小取决于服务

器的大小。



当服务器验证用户的信息通过的时候，创建对应的session文件，将session文件的标识（session_id）通过响应头

的set-cookie传给客户端，客户端拥有了开启session文件的一个号码牌，以后每次客户端请求服务器的时候都会

将session_id传递给服务器，服务器就可以根据session_id来读取指定session文件，来分辨用户的信息。



## cookie和session对比

办会员来说：

cookie是一张卡片，上面有你的头像，用户信息，以及公司的公章，去到公司使用的时候，带上会员卡-----cookie

session是一张卡片， 上面只是一串数字，去到公司使用的时候，读取卡片就可以获得用户的信息 ---- session



## token

token表示凭证、令牌

是由服务器来生成的，跟http协议没有任何的关系



**登陆实现**

当用户通过ajax或者表单发送请求的时候，请求到达服务器，服务器处理之后，会将用户的信息与秘钥一起生成一

个随机的字符串并签名,即是生成一个token字符串。用户所有的信息都在token字符串中，之后服务器不在保存用

户的信息，浏览器请求断开之后，记录这个token字符串，下次请求的时候必须携带该字符串，表单的隐藏域就可

以来进行传输token，服务器在判断用户请求的时候，就会判断用户的token是否合法，合法就处理，不合法直接

拒绝。可以根据token字符串判断用户的信息和登陆状态等。



## nodejs中的变量

使用nodejs的时候，没有书写任何的变量，但是可以调用http、fs、https、require、exports、module等等，为

什么这些可以使用？

其实，当我们执行nodejs命令的时候，并没有直接执行js文件，而是对js文件进行打包处理，打包成了模块



# 框架设计

## 一、MVC设计模式

MVC的思想很简单，就是“分层”。

以前写代码，都是所有的代码放在一起。功能实现了，但是显得很臃肿。

MVC的分层：分成三层。

M：Model 模型层      负责存储和提供数据

V：View  视图层      负责渲染页面

C：Controller 控制器层  负责实现逻辑交互



MVC的功能：

C是核心，可以从M中获取数据、更新数据 可以更新视图

V可以从M中获取数据

M只负责存储和提供数据



## 二、MVVM

M：模型层 负责存储数据

V：视图层 负责渲染视图

VM：视图模型层 负责将模型层与数据层联系起来

MVVM最大的特点：双向绑定

双向绑定：

​	当视图发生变化，能够影响到模型层的数据

​	当模型层中的数据发生改变，会立即渲染视图视图



## 三、NPM

### 3.1 介绍

NPM:Nodejs Package Manager(第三方包管理器)

在Nodejs中的模块文件分为两类：

- 核心模块文件 这种文件可以直接使用
- 第三方模块文件  所谓第三方模块每一个程序员都可以自定义的文件

Node_modules文件夹：

​	该文件的作用是用于存储所有的第三方模块文件，在该文件中的所有第三方模块文件，当我们引入的时候就可以像引入核心模块文件那样引入

### 3.2 使用

官网：https://www.npmjs.com

如果想要使用npm应用程序

我们必须先下载

该程序已经在下载nodejs程序的时候默认下载了

#### 3.2.1 使用指令

npm install ModelName

​	该条指令可以将ModelName下载到你的电脑中

npm install ModelName1 ModelName2 ModelName3

​	该条指令可以将多个模块文件一起下载到你的电脑中

**注1：**

当我们使用Npm指令时候，会先在同级目录寻找node_modules文件夹，如果同级没有则去上一级中查找，如果上一级还没有则会到上上级...， 如果找到则直接下载到找到的node_module文件夹中，如果直到盘符根目录下还没有该文件，则会回到你调用的时候的目录去创建一个node_modules文件夹并下载

**注2：**

如果当前目录下存在一个package.json文件，则下载的模块文件不会继续往上找了，直接在当前层级中直接下载

 

**注3：**

如果在下载文件的时候，输入指令 npm install modelName --save 

则会将下载的模块文件存储在package.json文件中的dependencies中  ‘运行时候的模块’

 

如果在下载文件的时候，输入指令 npm install modelName --save-dev 

则会将下载的模块文件存储在package.json文件中的devDependencies中  ‘开发时候的模块’

#### 3.2.2 package.json

每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称/版本/许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需要的模块，也就是配置项目所需的运行和开发环境。

#### 3.2.3 生成package.json文件

通过 npm init 指令即可生成该文件

根据提示信息输入完毕之后，会自动生成package.json文件

#### 3.2.4 下载别人的项目

指令：npm install

当我们写完一个项目的时候，可以将项目上传到git中，我们还可以下载别人的项目，但是项目可能需要依赖一些模块，此时我们就可以通过指令去下载package.json文件中的dependencies和devDependencies中所有依赖的模块，才能够启动一个项目



# Express

### 1.1 介绍

Express 是基于Nodejs平台的，快速、开放、极简的web开发框架

可以帮助我们快速的搭建后台服务器，快速处理post请求，快速处理静态功能.....

### 1.2 官网

地址：https://www.expressjs.com.cn/



### 1.3 下载

npm install express

### 1.4 使用

### 1.5 静态功能

我们想要访问一个页面的时候，我们可以利用express的唯一一个中间件static，实现静态服务器功能

> demo

```js
// 引入express
var  express = require('express');
// 构建应用
var app = new express();

// 搭建静态服务器
// app.use(express.static('./web'))
// nodejs中的 / 盘符的根目录， web中的 / 是由服务器设置的
app.use('/banma', express.static('./web'))

// 监听端口
app.listen(80,function() {
    console.log('服务器运行了');
});
```

express.static(定义web服务器根路径)

app.user(第一个参数路径)： 如果存在第一个路径，则在输入url的时候必须在根路径前面加上的一个路径

比如有'/banma'则访问路径为：http://localhost:3000/banma/index.html

没有第一个参数则访问路径为：http://localhost:3000/index.html

### 1.6 处理get请求

在Express中处理get请求有两种方式：

- 通过app.get方法
- 通过Router路由对象处理

第一种使用方式：

	app.get(path, callback)
	
		path:合法的路径
	
		callback：回调函数
	
				函数中有三个参数：
	
						第一个参数： req请求头对象
	
						第二个参数：res 响应对象
	
						第三个参数： next方法 是一个放行函数

> 执行代码：

```js
// 引入express
var express = require('express');

// 构建应用
var app = new express();

// 设置请求接口
app.get('/aa', function(req, res, next) {
    console.log('正在请求aa接口');
    console.log(arguments.length);
    /*
        req: 代表请求对象
        res： 响应对象
        next: 放行函数
    */ 
    // 获得用户请求的内容
    console.log(req.query);   
    // 响应
    res.send(JSON.stringify(req.query));
})

// 设置监听端口
app.listen(80);
```

#### 1.6.1 获得query数据

想要获取query数据，可以通过req.query获取前端提交的数据

req.query是express对原生的Node请求头对象添加的属性

#### 1.6.2 放行函数

在Express中允许对一个接口，添加多个处理函数

> demo：

```js
// 引入express
var express = require('express');
// 构建应用
var app = new express();

// 设置接口
/* 
    next: 放行函数的意义
    意义： 可以让express针对于同一个接口有多个处理方法
*/
app.get('/aa', function(req, res, next) {
    // console.log(next);
    console.log(11111111);
    next();
    console.log(2222222);
})
app.get('/aa', function(req, res, next) {
    // console.log(next);
    console.log(333333);
    next();
})
app.get('/aa', function(req, res, next) {
    // console.log(next);
    console.log(444444);
})
// 设置监听端口
app.listen(80);
```

<b style="color:red;">注意：放行函数之后的代码依旧可以执行</b>



### 1.7 Router路由对象

	Router是Express自带的一个构造函数，用于定义路由对象
	
	该路由对象可以用于处理各种请求

> 使用方式：

		通过express上的一个构造函数，得到一个Router对象 并执行

> <b style="color:red;">使用router对象的步骤：</b>

- 从express.Router获得构造函数
- new express.Router获得router对象
- 使用router对象处理请求
- 挂载router

<b style="color:red;">此时，所有的请求都可以通过Router路由对象处理，与app无关</b>

<b style="color:red;">注意： 路由的挂载决定了app.get和router.get的执行顺序</b>

但是只能处理，简单的post请求，无法处理携带的文件内容（文件的上传）

并且Router路由对象还可以提取到外部使用

> demo:

```js
/*
    路由：
        处理各种各样的请求
*/ 
// 引入express
var express = require('express');
// 获得路由的构造函数
var Router = express.Router;
// 构建应用
var app = new express();
// 获得路由对象
var router = new Router();

// 路由处理接口
router.get('/aa', function() {
    console.log('router.get 对应的aa接口触发了');
})
// 设置接口
// app.get('/aa', function(req, res, next) {
//     console.log('app.get 对应的aa接口触发了');
//     next();
// })

// 挂载router
app.use(router);
// 设置监听端口
app.listen(80, function() {
    console.log('服务器运行了');
})
```

> router处理get请求

```js
// 使用路由处理get请求
// 引入express
var express = require('express');
// 获得路由的构造函数
var Router = express.Router;
// 构建应用
var app = new express();
// 获得路由对象
var router = new Router();

// 路由处理接口
router.get('/aa', function(req, res) {
    // 处理get请求
    console.log(req.query);

})

// 挂载router
app.use(router);
// 设置监听端口
app.listen(80, function() {
    console.log('服务器运行了');
})
```

### 1.8 router处理post请求

处理post请求可以通过app.post还可以通过router.post

如果想要接受post请求发送的数据，我们必须借助一个中间件:body-parser

之后可以通过req.body获取前端提交的数据

> demo:

```js
// 引入express
var express = require('express');
// 引入body-parser
var body_parser = require('body-parser');
// 构建应用
var app = new express();
// 获得路由对象
var router = new express.Router();

// post请求
router.post('/post', function(req, res) {
    console.log('post请求触发了');
    // console.log(arguments.length);
    console.log(req.body);
})

// 需要设置post的解析
app.use(body_parser.urlencoded({extended: false}));



// 构建一个静态服务器
app.use(express.static('./web'));

// 挂载路由
app.use(router);
// 监听端口
app.listen(80, function() {
    console.log('服务器运行了');
});
```



> urlencoded参数说明：

- `extended: false`：表示使用系统模块querystring来处理，也是官方推荐的
- `extended: true`：表示使用第三方模块qs来处理
- 从功能性来讲，qs比querystring要更强大，所以这里可以根据项目的实际需求来考虑

> post请求的数据接收

1. 引入模块body-parser
2. 设置模块：app.use(body_parser.urlencoded({extended: false}));
3. 通过req.body获得请求数据



## 二、Express中设置cookie

### 2.1 介绍

cookie是http协议中请求头的一个字段

用于验证用户是否登录

是由服务器来设置的，由浏览器来保存

登录原理：

		当用户通过表单或者是AJAX提交数据的时候， 浏览器会发送请求到服务器，之后服务器经过验证之后，会在响应头中的set-cookie中设置用户的信息，然后返回给浏览器，浏览器接收到响应之后，根据HTTP协议中的规定解析set-cookie中的内容，于是生成一个cookie文件，将用户的信息保存，之后浏览器发送同一个服务器请求的时候，都会将cookie文件中的内容通过cookie字段携带到服务器中，服务器就可以通过cookie字段来判断用户是否登录过。



### 2.2 设置cookie

我们可以通过res.cookie(key, value, options)

	key: 要设置的属性名
	
	value：属性值
	
	options：配置对象







### 2.3 获取cookie中的内容

我们可以通过req.cookies即可查看cookie中的内容

但是我们需要一个中间件 cookie-parser

**使用方式：**

1. 下载 npm install cookie-parser

2. 引入cookie-parser

3. 配置

   ```js
   // 配置cookie-parser
   app.use(cookie_parser());
   ```

<b style="color:red;">cookie的生命周期可以在设置cookie的时候通过配置对象options的maxAge属性进行设置，默认为关闭浏览器则清除cookie</b>

### 2.4 Express中session

我们可以通过req.session来设置或者用于获取session中的内容

但是，当我们要获取session中的内容的时候，要借助于中间件：express-session

> 使用方式：

1. 下载 npm install express-session

2. 引入express-session

   ```
   // 引入express-session模块
   var express_session = require('express-session');
   ```

3. 配置session

   ```js
   // 配置session
   app.use(express_session({
       secret: 'iloveyou',
       resave: false,
       saveUninitialized: false,
       cookie: {
           maxAge: 1000 * 60 * 60 * 24
       }
   }))
   ```

   

   | 参数              | 作用                                                         |
   | ----------------- | ------------------------------------------------------------ |
   | secret            | 一个 String 类型的字符串，作为服务器端生成 session 的签名。  |
   | name              | 返回客户端的 key 的名称，默认为 connect.sid,也可以自己设置。 |
   | resave            | 强制保存 session 即使它并没有变化,。默认为 true。建议设置成 false。 don't save session if unmodified |
   | saveUninitialized | 强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。(默 认:true)。建议手动添加。 |
   | cookie            | 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。 |
   | rolling           | 在每次请求时强行设置 cookie，这将重置 cookie 过期时间(默认:false) |

> demo:

```js
// 引入express
var express = require('express');
// 引入express-session
var express_session = require('express-session');
// 构建应用
var app = new express();
// 获得路由
var router = new express.Router();

// 设置session
router.get('/setSession', function(req, res) {
    req.session.islogin = true;
    req.session.username = 'sy102';
    console.log(req.session);

    res.send('设置session完毕');
})
// 获得session
router.get('/getSession', function(req, res) {
    console.log(req.session.islogin);
    console.log(req.session.username);
    res.end(JSON.stringify(req.session));
})

// 配置session
app.use(express_session({
    secret: 'iloveyou',
    resave: false,
    saveUninitialized: false,
    cookie: {
        maxAge: 1000 * 60 * 60 * 24
    }
}))
// 挂载路由
app.use(router);
// 设置监听端口
app.listen(80, function() {
    console.log('服务器运行了');
});
```



### 2.5 Token

含义：凭证、令牌

生成：由后端生成

存储：存储在前端的cookie中或者本地存储中

格式：头部，数据，签名

作用：验证用户身份

流程机制：

客户端使用用户名跟密码发送登录请求

服务端收到请求，去验证用户名与密码

验证成功后，服务端会生成一个 Token字符串，再把这个 Token字符串发送给客户端，服务器端不会保留该Token字符串。

客户端收到 Token字符串，可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里

客户端每次向服务端请求资源的时候需要带着服务端签发的 Token字符串

服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，响应本次请求，如果验证失败则服务器可以拒绝

特点：

服务器无状态 因为服务器只负责解密 而不负责存储

把所有状态信息都附加在 Token 上，服务器就可以不保存。但是服务端仍然需要认证 Token 有效。

只要服务端能确认是自己签发的 Token，而且其信息未被改动过，那就可以认为 Token 有效。“签名”就是做这个的。

Token 是在服务端产生的，如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。

前端可以在每次请求的时候带上 Token 证明自己的合法地位。如果这个 Token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。

JWT标准：

因为这个过程的验证并不是HTTP协议中规定的方式，而是自定义的。所以很可能一个公司就有一个公司的使用方式。（程序员们从一个公司到了另一个公司，还要再学习另一套使用方式）。所以，就出现了标准。

标准的 Token 有三个部分：

	header（头部）
	
	payload（数据）
	
	iss：Issuer，发行者
	
	sub：Subject，主题
	
	aud：Audience，观众
	
	exp：Expiration time，过期时间
	
	nbf：Not before
	
	iat：Issued at，发行时间
	
	jti：JWT ID
	
	signature（签名）
	
	header
	
	payload
	
	secret

 






> 使用步骤：

1. 引入jwt （jsonwebtoken） 需要先安装 npm install jsonwebtoken
2. 定义加密字符串
3. 通过jwt.sign(信息对象， 指定的加密字符串)方法进行加密生成token字符串
4. 通过jwt.vertify(token字符串， secret, callBack)解密

## 三、EJS

EJS是后台服务器模板，当用户登录成功之后可以通过模块渲染一个页面

EJS天生能与Express配合使用，无需引入，但是需要下载

### 3.1 使用

1. 下载： npm install ejs
2. 创建一个views文件夹
3. 所有的ejs文件都要存储在views文件中
4. 所有的文件后缀名必须是`.ejs`
5. 可以通过res.render(FilePath, dic)渲染页面
6. `<%=%>`是EJS模板的标准语法，并且`<%%>`之间是一个js环境
7. `<%=%>`第一个`<%`与`=`之前不能有空格 但是等号后面可以有空格



## 四、文件上传

### 4.1 单文件上传

当获取上传的文件需要借助插件: formidable

formidable是任何服务器都可以使用的插件，不是Express的专用插件

enctype="multipart/form-data"： 必须在form表单中 添加该设置 才可以使用formidable解析req对象

使用步骤：

- 下载 npm install formidable
- 引入该模块文件
- 实例化该构造函数
- 设置上传的路径 fd.uploadDir 
- 解析req对象 通过fd.parse(req, callBack)

> fd.parse说明：

```
fd.parse(req, function(err, data, files) {
    err为错误信息 null代表成功
    data为表单传送的数据
    files为文件上传的数据
})
```

### 4.2 多文件上传

如果想要上传多个文件的时候，如果只是使用单文件上传的方式，只会得到最后一个上传的文件，此时，要监听一个时间：file事件

该事件会在每一次上传的文件触发一次。



# MongoDB数据库

## 一、MongoDB数据库

数据库：存储数据的仓库

世界上有各种各样的数据库应用程序

大致可分为两类：

	SQL数据库： mySql、oracle、sqlserver等
	
	NoSql数据库： Mongodb数据库等

### 1.1 SQL数据库

结构化查询语言：structure query language 

它的结构组成：应用程序 => 数据库 => 表 => 数据

使用SQL数据库要学习SQL语言。

### 1.2 NoSql数据库

他的结构组成： 应用程序=》数据库=》集合=》文档

SQL与NOSQL的最大区别在于NoSql的集合中的文档，他的结构可以不固定。

### 1.3 安装数据库

官网： https://www.mongodb.com

下载安装包：点击右上角的try free按钮

按照步骤进行下载：

下载完成之后的安装包：



### 1.4 安装

安装完成之后的路径：C:\Program Files\MongoDB\Server\4.4\bin

找到：MongoDB



### 1.5 环境变量配置

环境变量是系统中的一个配置

作用用于扩大调用命令的范围

如何去设置系统环境变量那？

1. 右键我的电脑 --》点击属性
2. 找到高级系统设置
3. 找到环境变量
4. 点击之后，找到系统变量中的path点击编辑
5. 新建
6. 将C:\Program Files\MongoDB\Server\4.4\bin粘贴到字符串的后面 
7. 保存即可
8. 我们即可在全局中，调用命令，此时，不再出现“不是内部或者外部命令”



### 1.6 开启数据库

当需要开启一个数据库的时候需要输入指令：mongod

默认开启是C:/ data /db数据库  

默认端口是27017



于是我们可以在C盘中从创建一个data文件夹 并且还在该文件夹中创建一个db文件夹

该文件中的所有内容不要修改

如果我们需要开启另一个数据库的时候:

输入指令: 

举例：

```
mongod --dbpath c:/banma --port 27018
```

### 1.7 链接数据库

当需要链接某个数据库的时候，我们可以通过指令：mongo

如果想要连接其它数据库需要输入指令：

mongo --port 27018 

关闭数据库：

ctrl + c



## 二、MongoDB常用命令

1. 开启服务器

   ![image-20210413100150011](./assets/image-20210413100150011.png)

2. 链接服务器

   ![image-20210413100536172](./assets/image-20210413100536172.png)

   ![image-20210413100551981](./assets/image-20210413100551981.png)

3. 查看所有的数据库

   ![image-20210413100627048](./assets/image-20210413100627048.png)

4. 查看当前所在的数据库

   ![image-20210413100702149](./assets/image-20210413100702149.png)

5. 创建和切换数据库

   ![image-20210413100810599](./assets/image-20210413100810599.png)

   只有当数据库存在数据的时候，show dbs才会显示数据库

6. 删除所在的数据库

   ![image-20210413101113657](./assets/image-20210413101113657.png)

7. 创建集合并添加数据

8. 查看所有集合

   ![image-20210413101354624](./assets/image-20210413101354624.png)

9. 删除集合

   ![image-20210413101515687](./assets/image-20210413101515687.png)

10. 添加数据

    ![image-20210413101653600](./assets/image-20210413101653600.png)

11. 查看数据

    ![image-20210413101706817](./assets/image-20210413101706817.png)

12. 删除一条数据

    ![image-20210413101911121](./assets/image-20210413101911121.png)

13. 删除所有数据

    ![image-20210413101938515](./assets/image-20210413101938515.png)

14. 修改一条数据

    ![image-20210413102357296](./assets/image-20210413102357296.png)

15. 修改多条

    ![image-20210413102604847](./assets/image-20210413102604847.png)

MongoDB应用程序---》数据库---》集合-----》文档    字段 field相当于关系型数据库的column

- 查看所有数据库： show dbs
- 查看当前所在数据库： db
- 切换/创建数据库： use dbname
- 删除所在数据库：db.dropDatabase()
- 查看数据库中的集合： show collections
- 创建集合并添加数据： db.collectionName.insert({})
- 删除集合：db.collectionName.drop()
- 集合添加数据： db.collectionName.insert({})
- 集合查找数据： db.collectionName.find({}) ， 查看所有，对象中设置查询条件 findOne({}) 查询单条数据
- 集合删除数据：
  - 删除单条： db.collectionName.deleteOne({条件对象}) 删除一条
  - 通用操作：db.collectionName.remove({}) 空对象为删除所有，条件为多条， 可以设置对象中的justOne为true为删除一条
- 集合修改数据：
  - db.collectionName.update(query, update, options)
    - query: 修改条件
    - update：修改的数据{$set: {修改的数据对象}}
    - options： 配置独享
      - upsert：不存在的时候是否添加 默认为false， 指不存在匹配对象
      - multi： 是否更新多条数据 默认为false只更新一条数据， true则更新多条数据，要更新多条数据的时候，需要设置为true



## 三、NodeJS操作MongoDB数据库

Nodejs和MongoDB都是独立的应用程序

如果使用Nodejs操作MongoDB数据库呢？
需要下载一个模块： mongodb模块

下载： npm install mongodb

在文件中引入 mongodb





# ES6

如今以年份为标准定义ES规范的版本号了，ES6吸取了ES4的教训，新的特性没有要求浏览器一定要实现。而是自身编译成一个浏览器接受的版本，这样ES6的代码就可以在浏览器端运行了。所以受到很多浏览器的信任，很多浏览器开始支持它，如今高级的浏览器已经能够支持99%以上的语法了（firefox 基本都支持了），所以我们写的代码可以直接在浏览器端运行测试了

ES6着眼于企业级大型项目的开发，并且推荐面向对象编程，因此支持了很多新的关键字，如class，extends，static等等，但是ES6保留了js语言自身弱类型的特点，所以ES6开发效率很高。

在nodejs端，从6.0版本开始，支持ES6的语法了，因此可以直接用ES6开发node了

在浏览器端，为了兼容更多的浏览器。我们需要将ES6的代码，编译成浏览器支持的版本。

## 一、ES6

> ES6声明变量有三个： var、let、const

作用域划分：

1. 函数可以划分作用域，函数内部的统称为局部变量，函数外部的称之为全局变量------函数作用域
2. 块级作用域： {}

### 1.1 let关键字

let关键字适用于定义变量，支持块级作用域

之前使用的var定义的变量，是支持函数级作用域

> 使用var定义的变量:

- 在函数内部定义的变量，外部不能访问到
- 在if、for循环中定义的变量，外部是可以访问到的

**因此，使用var定义的变量，是一个函数级的作用域**

> 使用let定义的变量： 

- 在函数定义的变量，外部不能访问
- 在if、for循环中定义的变量，外部也不能访问到

**因此，使用let定义的变量是一个块级作用域**



> let变量的特点：

1. 支持块作用域
2. 不能重复定义
3. 无法声明前置
4. 不能被window挂载
5. 能够在for循环中保存变量

### 1.2 const关键字

const关键字用于定义常量（地址不变，不是值不变）

**常量：一旦定义，将无法改变的变量 **

> const常量的特点： 

1. 支持块作用域
2. 无法重复定义
3. 无法修改
4. 无法声明前置
5. 不能被window挂载
6. 不能作为for循环的变量使用
7. 值只能是值类型，如果是引用类型，则可以被修改

在工作中，通常使用const定义的变量要大写，单词之间要通过横线分隔



### 1.3 字符串拓展

ES6为字符串做了很多拓展

#### 1.3.1 多行字符串

单行字符串的问题：

一些特殊字符需要转移： \012

一些转义字符需要转移： \n

不能直接嵌入字符串标志符：

例如：

单引号嵌套单引号，需要转义

双引号嵌套双引号，需要转义

……

ES6为了解决这样的问题，提供了多行字符串，使用方式：``

在多行字符串中除了``不能书写, 可以直接书写任意字符串，包括换行符

并且在多行字符串中提供了插值语法${}, 在插值语法中是一个真正的js环境



#### 1.3.2 原始字符串

当我们使用转义字符的时候，并且在浏览的时候，我们看到的只是结果，不能够看到原始的字符串（转义字符）于是，ES6中拓展了String.raw方法，不会转义，可以显示完整原始字符串

使用方式：通过``调用



#### 1.3.3 重复字符串

在ES6中拓展了repeat方法用于重复字符串

参数就是要重复的次数

返回值就是重复的结果



#### 1.3.4 字符串位置

##### 1.3.4.1 startsWith

该方法用于判断子字符串是否在开头

使用方式：

str.starsWith(str, start)

str: 子字符串

pos: 要切割的位置（包含切割位置）保留的是后面的字符串



##### 1.3.4.2 endsWith

该方法用于判断子字符串是否在结尾

使用方式：

str.endsWith(str, start)

str: 子字符串

pos: 要切割的位置（**不包含切割位置**）保留的是前面的字符串



##### 1.3.4.3 includes

该方法用于判断是否包含字符串

使用方式：

str.includes(str, start)

str: 子字符串

start: 从哪里开始进行查找

1.3.5 字符串补全（ES7）

字符串补全

padStart

padEnd

### 1.4 数字拓展

ES6为Number拓展了几个方法：isNaN、 isFinite、isInteger

全局中有一个isNaN方法，用于判断是否是NaN(Not a Number)

全局中的isNaN方法在判断的时候，会做类型转换

而Number拓展的isNaN方法在判断的时候，不会做类型转换

首先必须是数字

其次才判断是否是NaN

如果是NaN则返回true

否则返回false 

ES6提供了Number.isNaN方法用来判断一个值是否严格等于NaN，它会首先判断传入的值是否为数字类型，如不是，直接返回false。

 

全局有一个isFinite判断是否是有限的

全局中的isFinite方法在判断的时候，会做类型转换

而Number拓展的isFinite方法在判断的时候，不会做类型转换

首先必须是数字

其次才判断是否是有限的

如果是有限的则返回true

否则返回false

 

Number提供了isInteger判断是否是整型

在判断的时候会做类型检验

首先必须是数字

其次才判断是否是整型

如果是整型则返回true

否则返回false

安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。



#### 1.4.1 数学对象拓展

就是对Math对象的拓展，

ES6为了更适应大型项目，解决自身运算的问题，拓展了大量的方法。

Math.cbrt：计算一个数的立方根。

Math.fround：返回一个数的单精度浮点数形式。

Math.hypot：返回所有参数的平方和的平方根。

Math.expm1(x)：返回ex - 1。

Math.log1p(x)：返回1 + x的自然对数。如果x小于-1，返回NaN。

Math.log10(x)：返回以10为底的x的对数。如果x小于0，则返回NaN。

Math.log2(x)：返回以2为底的x的对数。如果x小于0，则返回NaN。

三角函数方法

Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）

Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）

Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）

Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）

Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）

Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）

Math.sign 返回一个数字的标志，用来判断数字范围的

(0, Infinity] 		1

[-Infinity, 0)		-1

0 					0

-0 					-0

NaN 				NaN

### 1.5 对象拓展

ES6为对象做了许多拓展

- 对象表示，属性值为变量与属性名同名时省略

- 方法简写

- 属性名表达式:[属性名表达式]

- (...)运算符： ...对象名  引用对象的全部属性

- 对象的浅复制

#### 1.5.1 对象字面量

let obj = {}

省略：

1 如果对象中定义的 属性名称和赋值的属性值的变量是一致的，则可以省略属性名和冒号

2 我们可以通过[]来动态的设置属性名称，在[]中可以书写表达式

3 在对象中定义的方法，可以省略冒号和function关键字

#### 1.5.2 is

is方法用于判断两个参数是否是全等

之前通过 

== 在做判断的时候 会做类型转换

=== 在做判断的时候 不会做类型转换

全等判断的时候有几个问题：

1、 0 和 -0 在全等判断的时候得到的是true

	0和-0之间是差了一个符号位的，在二进制中，存储时候的类型是不同的

2 、NaN在全等判断的时候 得到的是false

所有的NaN表示“不是一个数字”，NaN就是一种数据类型，在存储的时候的地址是一样的

is方法在判断的时候：

	0 和 -0 得到的是false
	
	NaN和Nav得到的是true

#### 1.5.3 assign

ES6为对象拓展了assign方法用于复制对象，与jquery中、underscore中的extend方法一致

使用方式：

	Object.assign(target, obj1, obj2)
	
	target: 目标对象
	
	obj1, obj2 要复制的对象
	
	后面对象中的同名属性会覆盖前面对象中的同名属性

#### 1.5.4 浅复制和深复制

assign方法实现的是浅复制

浅复制：值类型是直接赋值，而引用类型只是改变指针，并不是真正的复制

深复制：值类型是直接赋值，而引用类型也是直接复制，不是改变指针

简单实现深复制： JSON.parse(JOSN.stringify)

jquery中的extend方法如果第一个参数传递true的情况下，则是实现的深复制

jquery中只是对对象以及数组进行处理，并没有对函数进行处理

### 1.6 数组拓展

#### 1.6.1 from

**from可以实现将类数组对象转为数组**

		类数组对象：可以通过索引值获取属性值，并且还具备length属性的这一类对象
	
		**类数组对象不能使用数组中的迭代器方法，ES6中为数组拓展了from方法可以将类数组转为真正的数组，就可以使用数组中的迭代器方法**
	
		使用方式：
	
					Array.from(arrlike, fn)
	
						arrlike: 类数组对象
	
						fn: 执行的函数
	
								函数中有两个参数
	
										第一个参数：成员值
	
										第二个参数：索引值
	
										作用域是window
	
						如果传递了执行函数，此时from方法的返回值就是执行函数组成的结果

总结：

from不但可以将类数组对象转为数组，还可以遍历类数组对象

#### 1.6.2 of

of是用于创建数组的

之前通过new Array() 或者是Array()创建出来的数组 存在一些问题

1 如果没有传递参数 得到是空数组

2 如果传递一个数字参数 得到的是带有长度的空数组

3 如果传递非数字参数 得到的是一个参数的数组

4 如果传递多个参数 得到都是成员



#### 1.6.3  查找成员

在ES5中为数组拓展了两个方法用于查找成员： indexOf、lastIndexOf方法

这两个方法的参数就是要**查找的成员**，找到返回索引值，找不到返回-1

ES6中为数组拓展了两个方法也是用于查找成员：find、findIndex

	允许参数是执行的函数
	
	参数就是要执行的函数

函数中有三个参数：

第一个参数：成员值

第二个参数：索引值

第三个参数：原数组

**find方法用于查找成员的，返回值就是查找到的成员，如果没有找到返回undefined**

**findeIndex方法用于查找成员的索引值，返回值就是查找到的成员的索引值，如果没有找到返回-1**

一旦找到就会立即停止遍历

```
find和findIndex的方法为执行函数， 函数的返回值为true的时候，则find返回值，findIndex返回索引位置。找不到，find返回undefined，findIndex返回-1
```

<b style="color:red;">实现find和findIndex</b>

#### 1.6.4 数组内部复制

ES6为了实现数组内部复制提供了copyWithin方法

使用方式：

arr.copyWithin(pos, start, end)

pos: 要粘贴的位置

start: 复制的起始位置（包含起始位置）

end: 复制的结束位置（不包含结束位置）

例如：

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].copyWithin(3, 6, 9)

结果：

[0, 1, 2, 6, 7, 8, 6, 7, 8, 9]

原数组发生改变



#### 1.6.5 数组迭代器方法

ES6为了遍历数组方法实现了数组的迭代器接口方法：keys、values、entries

keys: 用于索引值的

values: 用于获取成员值

entries: 获取索引值与成员值

	[index, item]

由于实现了数组迭代器方法所以我们可以通过for of方法进行遍历 或者通过next方法进行遍历

```js
for(let [key, value] of ['a', 'b'].entries()){
    console.log(key, value);
}
// 0 "a"
// 1 "b"
```

for of 方法是专门用于**遍历迭代器接口对象的方法**,数组本身就是一个迭代器对象

语法： for （let item of data） {}

可以向for in、for循环那样在循环体中使用continue break等关键字

它也可以遍历数组，但是无法使用索引值

我们可以在外部定义索引值，在内部改变 即可使用索引值

for in也可以遍历数组，但是获取的类型是字符串

 

使用next方法遍历迭代器接口的时候，返回值是一个对象：

value: 表示成员值

done: 表示是否完成

注意：当遍历完成之后

value 永远是undefined 

done的值用于是true

```
iterator 和 for...of 循环

Iterator（遍历器）的概念

JavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
遍历器能遍历对象，但是不能遍历所有对象。
```

## 三、webPack

### 3.1 简介

webpack是Nodejs的第三方模块

webpack是模块化打包工具

在webpack看来，一切都是模块

注意：webpack天生只能识别js文件

### 3.2 安装

需要通过两次安装：

第一次安装：全局安装 需要安装两个包 C:\Users\Administrator\AppData\Roaming\npm

npm install webpack@4.41.2  -g

npm install webpack-cli@3.3.9 -g

本地安装 （在开发目录下，注：可省略）

npm install webpack 

npm install webpack-cli

### 3.3 配置文件

当安装完毕webpack之后提供了一个webpack.config.js文件用于配置

我们主要就是学习该文件如何进行配置

**重要概念：**

**入口**：所有文件要打包的入口配置

**出口：**所有文件打包之后要进行的相关配置

**加载机：**webpack不能识别除了js文件之外的文件类型，比如css文件等，所以需要加载机的帮助

插件： webpack本身不具备的功能

> webpack.config.js

```js
// webpack 是模块化打包工具，遵循的是commonjs的规范
module.exports = {
    // 入口文件
    entry: '入口文件',
    // 出口配置
    output: {
        path: '生成文件的存放路径',
        filename: '文件名称',
    },
    module: {
        // 定义加载机规则
        rules: [
            {
                // 用于匹配
                test: '正则表达式',
                // 定义加载机
                loaders: '加载机'
            }
        ]
    },
    
}
```

### 3.4 入口配置

入口配置指的是文件打包开始的地方

通过entry属性进行配置：

属性值可以是字符串，表示单个文件路径 （对应一个页面）

可以是对象，表示多个文件路径 （对应多个页面）

注意：一个入口文件对应一个页面

### 3.5 出口配置

出口配置指定是打包完成之后的文件所在的目录

通过output属性进行配置：

属性值是一个对象

对象中可以配置两个属性：

path: 配置打包之后文件所在的目录 默认是 __dirname + ‘/dist’ (可以省略)

filename: 打包之后的文件名称，多入口的时候使用 '[name].js' 其中name表示对象中的键值

### 3.6 加载机的配置

#### 3.6.1 加载css文件

插件名称： style-loader css-loader

#### 3.6.2 加载图片

插件名称： url-loader@2.2.0  file-loader@4.2.0 

此时，图片都是以base64的表现形式展示

此时有一个问题：

我们都知道，base64字符串是为了减少http请求数量的发送，但是当图片转为base64之后如果比原图片还要大，反而得不偿失

所以，一般我们都会对资源进行限制，比如当图片超过了10kb的时候，就不要转为base64字符串了

需要借助一个插件：file-loader@4.2.0 (可以不用配置 ，但是必须下载该模块)

![image-20210421103955176](./assets/image-20210421103955176.png)

> demo:

```js
module.exports = {
    // 入口----单入口
    entry: './js/main.js',
    // 出口
    output: {
        // 文件夹
        path: __dirname,
        // 文件名
        filename: 'demo.js',
    },
    module: {
        // 定义加载机规则
        rules: [
            {
                // 用于匹配
                test: /(png|gif|jpeg|jpg)$/,
                // 使用插件
                loaders: 'url-loader?limit=' + 1024 * 10
            }
        ]
    },
    // 模式
    mode: 'development'

}
```



### 3.7 webpack服务器

在webpack中提供了一个指令 可是实现实时的监听打包更新

指令名称： webpack -w 实时监测打包

webpack中提供了webpack服务器

需要通过全局安装：

npm install webpack-dev-server@3.8.2  -g

本地安装：

npm install webpack-dev-server@3.8.2 

本地安装webpack

npm install webpack@4.41.2

npm install webpack-cli@3.3.9 

安装完毕之后我们就可以使用webpack-dev-server 代替webpack指令

此时我们可以在地址栏输入：localhost:8080 访问服务器



### 1.7 ES6编译ES5

ES6中提供的方法可能有些浏览器没有实现，我们可以将ES6转为ES5语法，这样就可以使其它浏览器支持了

我们可以利用webpack将ES6语法转为ES5

使用webpack的步骤：

1 定义webpack.config.js文件

2 要定义以es为后缀的文件（为了区别es6和js文件）

3 转为ES5所需要的模块：

```
babel-loader@7 babel-core@6 babel-preset-env
```

## 二、解构

所谓解构就是解构聚合数据

ES5中有两类聚合数据： 数组和对象

在之前对象中获取属性数据的方式，只能是通过点语法的方式

在之前在数组中属性数据的方式，只能通过中括号的方式获取

ES6简化了获取数据的方式，利用解构语法

### 2.1 解构对象

语法： let { key, key1, ...keys} = obj;

key1 相当于 obj.key1

key2 相当于 obj.key2

keys获取的是剩余的属性

如果没有剩余的属性，获取的是一个空对象

注意：解构出来的属性、变量一定是与对象中的属性是同名的

> 解构问题：

-  如果使用var进行解构，则会污染全局作用域，我们可以通过let关键字来解决

-  对于方法来说，一旦解构，方法中的this将发生改变

-  解构出来的方法，只是指针的改变，值类型的数据，是真正的复制

-  对象解构的逆运用，我们可以使用三个点语法，将对象中的数据传递给一个对象字面量中

### 2.2 解构数组

语法： let [arg, arg1, ...args] = arr;

arg表示第一个成员

arg1表示第二个成员

args表示剩余的所有成员

如果没有剩余的成员，则获取到的是一个空数组

如果使用var进行解构，也会污染全局作用域，我们可以通过let关键字解决

获取剩余参数的语法：

如果有剩余的成员，则可以获取数组中的所有成员

如果没有剩余的成员，获取到的就是一个空数组

前面的解构的变量，可以正常使用

逆运用：我们可以通过三个点语法，将数组中的参数，传递给一个数组字面量

此时将得到一个新数组

<b style="color:red;">总结</b>

```
解构赋值是对赋值运算符的扩展。
他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。
在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。
解构模型
在解构中，有下面两部分参与：
解构的源，解构赋值表达式的右边部分。
解构的目标，解构赋值表达式的左边部分。
```

## 三、函数拓展

### 3.1 默认参数

配置函数的默认参数的方式：

第一种可以通过||运算符进行适配

但是通过||运算符会忽略6个值为fales的参数： 0、’’、undefined、null、NaN、false

第二种可以通过三元运算符： ？ ：

但是参数过多，书写起来比较麻烦

ES6提供默认参数的语法： 直接在参数集合中为形参赋值

如果传递了参数，则使用传递的参数

如果没有传递参数，则使用默认参数

ES6提供的默认参数的适配方式与三元运算的方式是等价的 

### 3.2 获取剩余参数

之前我们获取剩余参数可以通过arguments来获取，但是arguments不是数组，不能使用数组的常用方法

ES6提供了获取剩余参数的语法

语法： 

function demo(arg, arg1, ...args) {}

arg表示第一个参数

arg1表示第二个参数

args表示剩余参数  

获取剩余参数的语法：

可以获取所有的参数

获取的剩余参数是一个数组，不包含前面的参数

前面的参数可以正常使用

在箭头函数中有广泛的应用

如果没有获取剩余的参数，arg则是一个空数组


逆运用：

语法：demo(...args)

我们可以将一个数组，作为参数传递到一个函数中

在之前我们可以通过apply方法将数组中的每一项传递到两一个方法中作为参数，但是在使用的时候要考虑this指向的问题

我们可以使用三个点语法，在传递参数的过程中则不需要考虑this指向问题

> 三个点语法总结：

解构对象中：

let {...keys} = obj;

逆运用：

let obj = { ...keys};

 

解构数组中：

let [...args] = arr;

逆运用：

let arr = [...args];

获取剩余参数：

function demo(...args) {}

逆运用：

demo(...args);

### 3.3 箭头函数

在之前定义函数的方式： 构造函数式、函数表达式、函数定义式

在ES6中新增了函数定义的方式：箭头函数

语法：

```
let demo = () => {}
(): 表示参数集合
=>: 是箭头函数的标志
{}：函数体
```

#### 3.3.1 省略

第一点省略： 当参数集合中只有一个参数的时候，可以省略参数集合

​	注意：如果使用三个点语法来获取剩余参数的话，则不能省略参数集合（）

第二点省略：如果函数体中只有返回值或者只有一句话我们可以省略return以及函数体

#### 3.3.2 特点

-  无法使用arguments获取剩余参数，但是我们可以通过三个点的语法来获取剩余参数


- 无法作为构造函数来使用

- 箭头函数的this指向永远是定义时的，也就是说在哪里定义this就指向谁


箭头函数的this指向永远是定义时的，无论call和apply或者bind都不能改变其作用域

改变箭头函数唯一的方式就是改变其宿主环境的作用域

 也就是说改变外部函数的作用域

## 四、Symbol

在js中的数据类型有6种：数字、字符串、布尔值、null、undefined、对象

在ES6中新增一种数据类型：Symbol类型 表示独一无二的数据

我们可以通过Symbol方法来创建Symbol数据

参数就是对Symbol数据的描述，但是它不影响结果

我们可以通过typeof 的方式来查看Symbol数据类型

如果传递的是一个对象，默认会调用其toString方法

我们还可以重写该方法

<b style="color:red;">Symbol数据类型是为了解决对象中同名属性覆盖的问题</b>

我们通过参加Symbol数据类型即可解决对象中同名属性覆盖的问题

通过Symbol创建出来的数据类型是无法通过for in查看数据，也无法通过Object.keys方法来查看

我们可以通过Object.getOwnPropertySymbols来查看内部数据

我们还可以通过变量名来查看对应的属性值

Object.keys方法用于查看对象中所有的属性数据

## 四、代理Proxy

在一些应用程序中总有一些重要的数据，不希望别人看到，但是在js中只要对象能够被访问，该对象就可以任意的被操作

ES6中拓展了代理方式，用于起到拦截保护重要数据的作用

使用方式：

return new Proxy(data, { get，set... })

data: 表示目标对象

{}: 操作对象

​	get(obj, key): 该方法用于获取属性数据

​		obj: 表示目标对象

​		key: 属性名称

​		返回值就是获取到的属性数据

​		作用域是当前操作对象

​	set(obj, key, value): 该方法是用于设置属性数据

​		obj: 表示目标对象

​		key: 属性名称

​		value: 属性值

​		作用域是当前操作对象

使用的代理与之前设置特性的方式相似

只不过设置特性是针对一个对象

而设置代码是针对两个对象

## 五、Reflect

Reflect是对对象的一些操作方法的封装

在之前，所有的方法都给了Objec添加了，它们都属于内部语言方法，在ES6中，将这些方法拿出来给了Reflect对象，因此以后调用对象内部方法的时候，通过Reflect对象调用

所以，在未来对象中的一些方法可以被移除，给Reflect对象添加

例如：

在之前设置特定的方式：

​		Object.defineProperty

现在设置特定的方式：

​		Reflect.defineProperty

**Reflect允许将一个运算符当做方法来使用**



has: 代替in运算符，判断对象中的某个属性是否存在 

deleteProperty: 删除对象中的属性

getOwnPropertyDescriptor: 获取对象中某个属性的描述对象

get: 获取属性数据

set: 设置属性数据



## 六、聚合数据

ES5中有两类聚合数据： 数组和对象

ES6中又新增了两类聚合数据： Set（WeakSet）、 Map（WeakMap）

### 6.1 Set

Set是实现了迭代器接口对象的去重数组

​	在去重的的时候不会做类型转换

Set实现了迭代器接口，因此可以使用for of进行遍历

在Set中提供了大量的方法，用于操作Set对象	

方法：

​	add: 用于添加数据

​	Clear: 清空数据

​	delete: 删除某一项数据

​	forEach: 用于遍历

​	has: 判断是否包含某个数据

​	size: 获取数据的长度

​	keys values entries: 获取迭代器接口对象

### 6.2 WeakSet

弱Set对象 参数只能是对象

里面也提供了一些方法用于操作WeakSet对象

add: 添加数据

delete: 删除某项数据

has: 判断某个属性是否存在

### 6.3 Map

Map是一个超级对象

​	在js中定义的属性名称必须是字符串

​	但是Map对象中添加的属性数据可以是任意类型（7种类型都可以）

​	里面也提供了大量的方法用于操作Map对象

方法：

​	Clear: 清空数据

​	delete: 删除某一项数据

​	forEach: 用于遍历

​	has: 判断是否包含某个数据

​	size: 获取数据的长度

​	keys values entries: 获取迭代器接口对象

​	set: 设置数据

​	get: 获取数据

### 6.4 WeakMap

弱Map对象 参数只能是对象

内部只提供了必要的方法用于操作该对象

方法：

​	delete: 删除某一项数据

​	has: 判断是否包含某个数据

​	set: 设置数据

​	get: 获取数据

## 四、Promise

Promise是将异步操作的写法变为同步操作的写法的一种规范

Promise规范在异步操作中有广泛的应用

Promise规范只是写法的改变，并不是将操作改变

​	异步操作：在回调函数中 一层一层的嵌套

​	同步操作：将方法写在外部

### 4.1 三个状态

在Promise中有三个状态：

​	1 pending: 操作正在进行

​	2 fulfilled: 操作执行成功

​	3 rejected: 操作执行失败



### 4.2 状态流向

在Promise中状态的流向有两个方向：

​	1 由pending状态流向fulfilled（resolved）状态，表示执行操作成功完毕

​	2 由pending状态流向rejected（failed）状态，表示执行操作失败完毕



### 4.3 使用

使用方式：

new Promise((resolve, reject) => {

​	// 执行异步操作，执行完毕

​	如果成功，则执行resolve

​	如果失败，则执行reject

})

 

在外部我们可以通过then方法监听异步操作成功还是失败	

.then(success, fail)

​	success: 成功时候执行的回调函数

​			该方法中的参数就是执行resolve方法的时候传递参数

​	fail：失败时候执行的回调函数

​			该方法中的参数就是执行reject方法的时候传递的参数

then方法的返回值是Promise对象，因此可以进行链式调用

​		上一个then方法返回值，将作为下一个then的参数来使用	

**注意： 如果在前面操作已经执行完毕，then方法将立即执行**

> 简单实现promise



## 五、监听状态

then方法： 可以监听成功或者是失败的方法

catch：用于监听失败时候的方法

finnally：无论成功还是失败都会执行的方法

### 5.1 all方法

可以监听多个Promise对象

参数是一个数组，数组中的每一项都是Promise对象

用then监听状态的变化

​	如果都执行成功才会执行success方法

​	如果有一个执行失败，就会执行fail方法

​		返回值是一个数组，里面的数据和Promise是一一对应的



### 5.2 race方法

一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。

参数是一个数组，数组中的每一项都是Promise对象

用then监听状态的变化

​	如果有一个执行成功，就会执行success方法

​	如果有一个执行失败，就会执行fail方法

​		返回值是成功时候的数据



### 5.3  resolve方法

是Promise的静态方法，返回一个监听resolved状态的Promise对象

参数有三种：

第一种：js数据

then方法会立即执行

第二种：Promise对象

第三种：thenable参数 （带有then方法的参数）

我们可以通过then方法监听状态的变化



### 5.4 reject方法

是Promise对象的静态方法，返回了一个监听rejected状态的Promise对象

参数就是错误描述



## 五、迭代器接口对象

ES6只提供了迭代器接口，但是没有具体的实现（类）

迭代器的作用：

​	1 定义了我们访问数据的次序

​	2 为所有的数据具备统一的接口，简单而方便的获取数据

​	3 为for of方式提供了访问数据的方式

注意：类数组对象可以添加数组迭代器遍历，但是对象是不能遍历的。



## 六、generator函数

generator函数是用于处理异步编程的解决方法（异步函数），内部封装了大量的状态，允许我们逐条遍历

语法：

function *demo() {

定义状态

}

我们可以通过yield关键字定义状态，yield关键字表示暂停的意思

注意：yield关键字只能在generator函数中使用

通过return返回最后一个状态，后面的yield状态不会在执行

generator函数的的返回值实现next方法，所以我们可以通过next方法逐条遍历内部的状态

next方法的返回值是一个对象：

对象中两个属性：done 表示是否完成， value表示状态数据

```
如果有状态，done是false， value就是状态值

如果没有状态，done是true,value是undefined
```

generator函数的的返回值实现了for of方法，所以我们也可以通过for of方法进行遍历

> 注意：for of和next方法不能同时使用，因为一方遍历完成，则另一方得不到数据

当generator函数遍历完成之后，此时它的状态变为close

当generator函数没有遍历完成的时候，此时它的状态变为suspended



### 6.1 数据传递

数据传递有两个方向：

1 数据由generator函数内部流入函数外部

2 数据由外部流入generator函数内部

#### 6.1.1  数据由内向外传递

1 要在generator函数中通过yield表示式，定义状态数据

2 在外部通过next方法中的value来获取数据

#### 6.1.2 数据由外向内传递

1 在外部通过next方法传递数据

2 在generator函数中通过yield表达式，接收数据

### 6.2 return

generator函数在原型上拓展了return方法，允许在函数外部终止内部遍历状态

如果在函数体中使用finally语句，return将会延后执行

### 6.3 throw

generator函数在原型上拓展了throw方法, 用于在外部抛出错误，在函数内部捕获

通过catch语法捕获

为了保证代码正常执行，我们可在函数内部定义try catch语句用于捕获错误

如果在外部抛出一个错误，在函数内部可以通过try catch语句捕获到

如果在外部抛出两个错误，一个在函数内部捕获，另一个在函数外部通过try catch语句捕获到

### 6.4 yield * 语法

yield *语法可以将函数内部的状态复制到另一个函数体中执行



### 6.5 三个点语法

通过三点个语法解构的时候，可以将一个函数中的所有状态值获取

### 6.6 this

在generator函数中的this指向是window

因此无法通过this去为对象添加任何的属性或者方法

我们可以在函数执行的时候， 通过call或者是apply改变函数执行时候的作用域，指向函数的原型即可添加方法

## 七、CO模块

Co模块是用于简化状态函数的启动过程

在ES6中想要使用，则必须下载该模块文件：

通过 npm install co

然后把里面co.js文件引入到页面中即可

在当前虽然可以实现我们的需求，但是状态与函数之间是强耦合，ES6为了解决这样的耦合关系

于是提供了Co模块，提供了co方法，用于简化状态函数的启动

并且可以通过then方法监听函数的执行结果

### 7.1 实现co方法





## 八、async与await

async与await是在ES2016(ES7)提出的规范

我们可以认为是generator函数的语法糖

语法糖：对一些复杂操作的简化，可以使我们进行简单的操作，从而提高开发效率

async 表示异步函数	

代表了 * 语法

await表示等一等的意思，执行到await的时候，会继续执行当前程序中的代码，后续的代码才会执行

代表 yield语法

 

特点与作用：

1 提高了代码的语义化

2 async函数中的数据可以是任意类型

co方法中的yield后面定义的数据类型不能是值类型

3 async函数的返回值是Promise对象

4 在函数中内置了状态函数的启动器

不需要通过next方法逐条遍历

 

当程序执行到await的时候，会交出程序的控制权，只有当后续代码执行完毕之后，才会继续执行await后面的代码

如果在await后面出现其他的数据，返回一个监听resolved状态的Promise对象

如果在函数中出现错误，函数会继续执行，会将错误信息追踪到Promise对象中



### 8.1 返回对象

async返回的是一个Promise对象 因此，

当执行成功的时候，我们在外部可以通过then方法监听状态结果

当执行失败的时候，我们在外部可以通过catch方法监听状态结果

await与yield一样

await只能出现在async中

yield只能出现在generator中



## 九、类

ES6之前我们通过构造函数来模拟类

在ES6中实现了类

语法：

class className {

}

在ES6之前定义类的方式： 





在类中我们可以定义三种数据：

​	第一种自身属性数据：

​		我们可以通过constructor函数定义自身属性数据（属性、方法）

​		定义的这些数据将被添加在每一个实例对象中

​	第二种原型数据：

​		我们直接在类体中定义方法即可

​		但是，如果想要定义原型属性数据，则必须通过设置特性的方式：get set方法来设置

​			get方法 取值器

​			set方法 赋值器

​		由于设置了特性方法，在查看对象的时候，这些原型属性数据会直接在对象中查看到

​	第三种静态数据： 实例化对象不能访问，只能类直接访问

​	添加静态数据的方式有两种：

​			第一种在类体中：

​			我们可以在数据的前面加上 static关键字即可

​			第二种：

​			在类的外部直接添加

​		区别：

​			在类体中，设置了特性

​			在类体外部，没有设置特性



## 十、继承

ES6中通过extends实现继承

语法：

class child extends father {}

当继承了父类之后将得到父类中的所有内容

我们可以重写继承过来的属性和方法，此时，子类将会优先使用重写的属性和方法

如果要重写构造函数，必须在构造函数中使用super关键字实现继承

并且还要传递必要的参数

在函数中定义的其它属性，一定要在super关键字之后定义



## 十一、ES Module

ES Module模块化开发规范已经被纳入ES2016(ES7)中

引入模块通过import关键字

引入模块的方式：

​	第一种 impot * as 模块 from 地址

​			实现将所有接口同时引入，放入模块中

​	第二种 import { data } from 地址

​			可以解构出某几个接口		

​	第三种 import 模块 from 地址

​			引入默认接口

暴露接口的方式：

​	1 通过export 向外暴露

​	2 通过export default 向外暴露默认接口

高级写法： 我们可以通过逗号，将默认接口与解构出来的接口同时引入

 

如果想要引入css文件，需要借助加载机的帮助

引入css文件的方式有两种：

​	1 可以作为模块来引入

​	2 可以直接引入 (常用)



> 核心：

- 定义模块
- 引入模块

ES Module模块化开发规范已经被纳入ES2016(ES7)中

引入模块通过import关键字

引入模块的方式：

- ​	第一种 import * as 模块 from 地址


​			实现将所有接口同时引入，放入模块中

- ​	第二种 import { data } from 地址


​			可以解构出某几个接口		

- ​	第三种 import 模块 from 地址


​			引入默认接口

暴露接口的方式：

​	1 通过export 向外暴露

​	2 通过export default 向外暴露默认接口

高级写法： 我们可以通过逗号，将默认接口与解构出来的接口同时引入

 

如果想要引入css文件，需要借助加载机的帮助

引入css文件的方式有两种：

​	1 可以作为模块来引入（他没用，暴露出来的是一个空对象）

​	2 可以直接引入 (常用)



> webpack.config.js

```js
// 配置
module.exports = {
    // 入口
    entry: './main.js',
    // 出口
    output: {
        path: __dirname,
        filename: 'demo.js',
    },
    // 配置module
    module: {
        // 配置规则
        rules: [
            {
                // 匹配的内容
                test: /\.js$/,
                // 加载机
                loaders: 'babel-loader',
                // 配置选项
                options: {
                    presets: ['env']
                }
            },
            {
                // 匹配的内容
                test: /\.css$/,
                // 加载机
                loaders: 'style-loader!css-loader'
            }
        ]
    },
    mode: 'development'
}
```

> 暴露接口

```js
// 引入其他模块文件
import xxoo from './demo.js';
console.log(xxoo);
// 定义模块
export let a = 111;
export let name = 'sy102';
export let fn = () => {
    console.log('fn');
}
export let obj = {
    name: '234',
    sex: 'nan'
}

let demo = {
    name: 'demo'
}
// export default demo;
export default {
    name: 'default'
}

```

> 引用模块，接收接口：

```js
// 引入模块
// 1、引入所有模块
// import * as xxoo from './xxoo.js';
// console.log(xxoo);

// 2、使用结构，获得指定的接口
// import {name, fn} from './xxoo.js';
// console.log(name);
// console.log(fn);

// 3、导入默认的接口
// import demo from './xxoo.js';
// console.log(demo);

// 高级用法
import sy, {name, obj} from './xxoo.js';
console.log({sy, name, obj})
```

<b style="color:red;">注意： 解构不能重名</b>

> css文件的引入：需要下载对应的模块 style-loader css-loader

```js
// 引入css文件
import css from './css/style.css'
console.log(css); // 空对象没用

// 直接加载css文件
import './css/index.css';
```



### 11.1 编译ES6

> babel

全局安装babel指令: npm install -g babel-cli 

检测： babel -V

项目安装：npm install babel-preset-es2015

配置`.babelrc`文件

```
通过presets配置项定义编译器
```

编译文件

```
输出到控制台 babel 文件
输出到文件中 babel 文件 --out-file 文件名
```

> webpack

所需模块：babel-loader@7 babel-core@6 babel-preset-env

配置：

```
rules: [
    {
        test: 匹配规则,
        loader: 'babel-loader',
        options: {
            presets: ['env']
        }
    }
]
```

